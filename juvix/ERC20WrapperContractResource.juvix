module ERC20WrapperContractResource;

import Stdlib.Prelude open hiding {to};
import Stdlib.Debug.Fail open;
import Applib open;

import Types open;
import ERC20Resource open using {owner as erc20Owner};
import Helpers open;
import Anoma open using {module ExternalIdentity; module InternalIdentity};

-- 0xa9059cbb;
transferSelector : ByteArray := todo;
-- functionSelectorFromString("function transfer(address, uint256) returns (bool)");
--  mkByteArray
--  [0xa9; 0x5; 0x9c; 0xbb];

transferEvmInput (to : ExternalIdentity) (quantity : Nat) : ByteArray :=
  builtinEvmEncode
    (transferSelector
      , (to
        |> ExternalIdentity.ExternalIdentity.unExternalIdentity
        |> builtinEvmEncode)
      , builtinEvmEncode quantity);

-- 0x23b872dd
transferFromSelector : ByteArray := todo;
-- functionSelectorFromString("function transferFrom(address, address, uint256) returns (bool)");
--  mkByteArray
--  [0x23; 0xb8; 0x72; 0xdd];

transferFromEvmInput
  (from to : ExternalIdentity) (quantity : Nat) : ByteArray :=
  builtinEvmEncode
    (transferFromSelector
      , (from
        |> ExternalIdentity.ExternalIdentity.unExternalIdentity
        |> builtinEvmEncode)
      , (to
        |> ExternalIdentity.ExternalIdentity.unExternalIdentity
        |> builtinEvmEncode)
      , builtinEvmEncode quantity);

transferFromEvmOutput : ByteArray := builtinEvmEncode true;

transferEvmOutput : ByteArray := transferFromEvmOutput;

{- LOGIC -}
erc20WrapperContractLogic (pub : Instance) (priv : Witness) : Bool :=
  let
    tag := Instance.tag pub;
  in if
    {- Wrapper contract resource consumed -}
    | isNullifier tag :=
      case findResourceByNullifier tag priv of {
        | nothing := false
        | just self :=
          if
            {- initializing consumption -}
            | Resource.ephemeral self := initializationLogic
            {- conventional consumption -}
            | else := true
      }
    {- Wrapper contract resource created -}
    | isCommitment tag :=
      case findResourceByCommitment tag priv of {
        | nothing := false
        | just self :=
          if
            {- finalizing creation -}
            | Resource.ephemeral self := false
            {- conventional creation -}
            | else := creationLogic self priv
      }
    | else := false;

--- Currently, the protocol adapter can create this resource directly and only once (with a fixed label, logic, value, quantity, and nonce).
--- TODO adapt eventually
initializationLogic : Bool := false;

creationLogic (self : Resource) (priv : Witness) : Bool :=
  case Witness.consumed priv, Witness.created priv of
    | [a; b], [x; y] :=
      let
        ((consumedWC, createdWC), consumedERC20, createdERC20) :=
          matchKinds self a b x y;
        (wrappedResourceKindInSelf, inputWithSelector, output)
          : Pair Kind (Pair ByteArray ByteArray) :=
          builtinAnomaDecode (Resource.value self);
      in same-kind?
          [
            decodeWrappedResourceKindFromValue consumedWC;
            decodeWrappedResourceKindFromValue createdWC;
            wrappedResourceKindInSelf;
            kind consumedERC20;
            kind createdERC20;
          ]
        && let
             selector := functionSelector inputWithSelector;
             input := functionCalldata inputWithSelector;
           in case both Resource.ephemeral (consumedERC20, createdERC20) of {
                {- ERC20 resource initialization -}
                | false, true :=
                  if
                    | selector == transferFromSelector :=
                      checkTransferFromCompliance@{
                        input;
                        output;
                        consumedWC;
                        createdERC20;
                      }
                    | else := false
                {- ERC20 resource finalization -}
                | true, false :=
                  if
                    | selector == transferSelector :=
                      checkTransferCompliance@{
                        input;
                        output;
                        consumedWC;
                        consumedERC20;
                      }
                    | else := false
                {- ERC20 resource transfers -}
                | _, _ := false
              }
    | _, _ := false;

checkTransferFromCompliance
  (input output : ByteArray) (consumedWC createdERC20 : Resource) : Bool :=
  let
    ((from, to), value) : Pair (Pair ExternalIdentity ExternalIdentity) Nat :=
      builtinEvmDecode input;
    evmCallSuccess : Bool := builtinEvmDecode output;
    wrapperContract : ExternalIdentity :=
      decodeWrapperContractAddressFromLabel consumedWC;
    createdERC20Owner := createdERC20 |> erc20Owner;
    createdERC20Quantity := createdERC20 |> Resource.quantity;
  in evmCallSuccess
    -- The funds must be transferred to the wrapper contract.
    && wrapperContract == to
    -- The created non-ephemeral resource must be owned by the `from` address from which the funds were transferred.
    && createdERC20Owner == from
    -- The quantity of the non-ephemeral resource must equal the value that has been transferred.
    && createdERC20Quantity == value;

checkTransferCompliance
  (input output : ByteArray) (consumedWC consumedERC20 : Resource) : Bool :=
  let
    (to, value) : Pair ExternalIdentity Nat := builtinEvmDecode input;
    evmCallSuccess : Bool := builtinEvmDecode output;
    consumedERC20Owner := consumedERC20 |> erc20Owner;
    consumedERC20Quantity := consumedERC20 |> Resource.quantity;
  in evmCallSuccess
    -- The consumed non-ephemeral resource must be owned by the `to` address to which the wrapper contract will transfer the funds.
    && consumedERC20Owner == to
    -- The quantity of the non-ephemeral resource must equal the value that has been transferred.
    && consumedERC20Quantity == value;

{- RESOURCE -}

--- NOTE: Only the wrapper label is enforced by the protocol adapter.
--- The wrapper logic and value  can be customized to correspond to other EVM state changes.
mkERC20WrapperContractResource
  (logic : Logic)
  (wrappedResourceKind : Kind)
  (ffiCall : FfiCall)
  (nonce : Nat)
  {ephemeral : Bool := false}
  : Resource :=
  mkResource@{
    logic;
    label := builtinAnomaEncode (FfiCall.address ffiCall);
    value :=
      builtinAnomaEncode
        (wrappedResourceKind, FfiCall.input ffiCall, FfiCall.output ffiCall);
    quantity := 1;
    ephemeral;
    nullifierKeyCommitment :=
      builtinAnomaEncode Universal.nullifierKeyCommitment;
    nonce;
    randSeed := 0;
  };

decodeWrapperContractAddressFromLabel
  (wrapperResource : Resource) : ExternalIdentity :=
  wrapperResource |> Resource.label |> builtinAnomaDecode;
