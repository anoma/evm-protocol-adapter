module ERC20Resource;

import Stdlib.Prelude open;
import Applib open;

import MagicNumbers open;
import Types open;

isAuthorizedBy
  (signer : ExternalIdentity) (origin : Nat) (publicInputs : Instance) : Bool :=
  TODO;

{- LOGIC -}

logic (publicInputs : Instance) (privateInputs : Witness) : Bool :=
  let
    tag := Instance.tag publicInputs;
    customInputs := Witness.customInputs privateInputs;
  in if
    | isNullifier tag :=
      case findResourceByNullifier tag privateInputs of {
        | nothing := false
        | just self :=
          if
            | Resource.ephemeral self := initializationLogic
            -- && requireResourceInAppData self tag publicInputs
            | else := consumptionLogic tag self publicInputs
      }
    | isCommitment tag :=
      case findResourceByCommitment tag privateInputs of {
        | nothing := false
        | just self :=
          if
            | Resource.ephemeral self := finalizationLogic
            | else := creationLogic
      }
    | else := false;

--- Requires a W
initializationLogic : Bool := TODO;

--- Transferable token logic
consumptionLogic
  (tag : Nat) (self : Resource) (publicInputs : Instance) : Bool :=
  isAuthorizedBy@{
    signer := owner self;
    origin := tag;
    publicInputs;
  };
creationLogic : Bool := true;

--- Requires a wrapper contract resource to be created that contains an FFI call to a wrapper contract method `unwrap` function with matching `owner` and `quantity` that in turn calls `transfer`. 
finalizationLogic : Bool := TODO;

{-
requireResourceInAppData
(self : Resource) (tag : Tag) (publicInputs : Logic.Instance) : Bool :=
let
appData := Logic.Instance.appData publicInputs;
lookUp :=
case tag of
| Consumed nullifier :=
lookupAppData@{
key := bitwiseXOR nullifier WRAP_MAGIC_NUMBER;
Value := Resource;
appData;
}
| Created commitment :=
lookupAppData@{
key := bitwiseXOR commitment UNWRAP_MAGIC_NUMBER;
Value := Resource;
appData;
};
in case lookUp of
| nothing := false
| just resource := resource == self;
bitwiseXOR {A} (a : A) (b : ByteArray) : ByteArray := TODO;
-}

{- RESOURCE -}

mkErc20Resource
  (erc20Token : Address)
  (wrapperContract : Address)
  (owner : ExternalIdentity)
  (quantity : Nat)
  (nonce : Nat)
  {nkc : NullifierKeyCommitment := Universal.nullifierKeyCommitment}
  {ephemeral : Bool := false}
  : Resource :=
  mkResource@{
    logic;
    label := builtinAnomaEncode (wrapperContract, erc20Token);
    value := builtinAnomaEncode owner;
    quantity;
    ephemeral;
    nullifierKeyCommitment := builtinAnomaEncode (nkc);
    nonce;
    randSeed := 0;
  };

{- HELPERS -}

owner (resource : Resource) : ExternalIdentity :=
  resource |> Resource.value |> builtinAnomaDecode;
