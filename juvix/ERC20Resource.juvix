module ERC20Resource;

import Stdlib.Prelude open;
import Applib open;
import Types open;
import Helpers open;

{- LOGIC -}

logic (publicInputs : Instance) (privateInputs : Witness) : Bool :=
  let
    tag := Instance.tag publicInputs;
  in if
    {- ERC20 resource consumed -}
    | isNullifier tag :=
      case findResourceByNullifier tag privateInputs of {
        | nothing := false
        | just self :=
          if
            {- initializing consumption -}
            | Resource.ephemeral self :=
              requireWrapperContractTransition self privateInputs
            {- conventional consumption -}
            | else :=
              isAuthorizedBy@{
                signer := owner self;
                origin := tag;
                publicInputs;
              }
      }
    {- ERC20 resource created -}
    | isCommitment tag :=
      case findResourceByCommitment tag privateInputs of {
        | nothing := false
        | just self :=
          if
            {- finalizing creation -}
            | Resource.ephemeral self :=
              requireWrapperContractTransition self privateInputs
            {- conventional creation -}
            | else := true
      }
    | else := false;

requireWrapperContractTransition
  (self : Resource) (privateInputs : Witness) : Bool :=
  -- require wrapper contract resource to be consumed/created
  case Witness.consumed privateInputs, Witness.created privateInputs of
    | [a; b], [x; y] :=
      let
        ((consumedERC20, createdERC20), consumedWC, createdWC) :=
          matchKinds self a b x y;
      in same-kind?
          [
            decodeWrapperResourceKindFromLabel consumedERC20;
            decodeWrapperResourceKindFromLabel createdERC20;
            kind consumedWC;
            kind createdWC
          ]
        {- The following is redundant since the wrapper contract checks this already.
        && same-kind?
          [
            decodeWrappedResourceKindFromValue consumedWC;
            decodeWrappedResourceKindFromValue createdWC;
            kind self;
            kind consumedERC20;
            kind createdERC20;
          ]
        -}
    | _, _ := false;

{- RESOURCE -}

-- should only be initializable/finalizable if wc is consumed
mkErc20Resource
  (erc20Token : Address)
  (wrapperResourceKind : Kind)
  (owner : ExternalIdentity)
  (quantity : Nat)
  (nonce : Nat)
  {nkc : NullifierKeyCommitment := Universal.nullifierKeyCommitment}
  {ephemeral : Bool := false}
  : Resource :=
  mkResource@{
    logic;
    label := builtinAnomaEncode (wrapperResourceKind, erc20Token);
    value := builtinAnomaEncode owner;
    quantity;
    ephemeral;
    nullifierKeyCommitment := builtinAnomaEncode nkc;
    nonce;
    randSeed := 0;
  };

{- HELPERS -}

decodeWrapperResourceKindFromLabel (wrappedResource : Resource) : Kind :=
  let
    (wrapperResourceKind, _) : Pair Kind Address :=
      builtinAnomaDecode (Resource.label wrappedResource);
  in wrapperResourceKind;

owner (resource : Resource) : ExternalIdentity :=
  resource |> Resource.value |> builtinAnomaDecode;
